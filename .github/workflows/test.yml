name: Test

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    services:
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
    - uses: actions/checkout@v4

    - name: Install pnpm
      uses: pnpm/action-setup@v4
      with:
        version: 10

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'pnpm'

    - name: Install dependencies
      run: pnpm install --frozen-lockfile

    - name: Install Redis CLI
      run: |
        sudo apt-get update
        sudo apt-get install -y redis-tools

    - name: Run linter
      run: pnpm lint

    - name: Run type check
      run: pnpm build
      env:
        # Provide environment variables for Next.js build
        NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL || 'https://your-project-id.supabase.co' }}
        NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY || 'your_anon_key_here' }}
        NEXT_PUBLIC_NOVU_APPLICATION_IDENTIFIER: ${{ secrets.NEXT_PUBLIC_NOVU_APPLICATION_IDENTIFIER || 'your_app_identifier' }}
        NOVU_SECRET_KEY: ${{ secrets.NOVU_SECRET_KEY || 'your_cloud_secret_key' }}
        DATABASE_URL: ${{ secrets.DATABASE_URL || 'postgresql://postgres.your-project-id:your-password@aws-0-region.pooler.supabase.com:6543/postgres' }}
        SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY || 'your_service_role_key_here' }}
        # Rule engine settings
        REDIS_URL: redis://localhost:6379
        RULE_ENGINE_ENABLED: true
        RULE_ENGINE_TIMEZONE: UTC
        RULE_ENGINE_MAX_CONCURRENT_JOBS: 10
        RULE_ENGINE_RETRY_ATTEMPTS: 3
        RULE_ENGINE_RETRY_DELAY: 5000

    - name: Verify Redis connection
      run: |
        redis-cli -h localhost -p 6379 ping
        echo "Redis is ready"

    - name: Verify Novu connection
      run: |
        echo "üîî Testing Novu connection..."
        if [ -n "$NOVU_SECRET_KEY" ] && [ "$NOVU_SECRET_KEY" != "your_cloud_secret_key" ]; then
          echo "‚úÖ Novu secret key is configured"
          
          # Test actual Novu API connection using credentials
          echo "üß™ Testing Novu API with credentials..."
          NOVU_RESPONSE=$(curl -s -w "%{http_code}" -o /tmp/novu_response.json \
            --connect-timeout 10 \
            -H "Authorization: ApiKey $NOVU_SECRET_KEY" \
            -H "Content-Type: application/json" \
            "https://api.novu.co/v1/environments")
          
          HTTP_CODE=$(echo "$NOVU_RESPONSE" | tail -c 4)
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Novu API connection successful"
            # Check if we can access environments
            if command -v jq >/dev/null 2>&1; then
              ENV_COUNT=$(jq '.data | length' /tmp/novu_response.json 2>/dev/null || echo "0")
              echo "üìä Found $ENV_COUNT Novu environments"
            fi
          elif [ "$HTTP_CODE" = "401" ]; then
            echo "‚ùå Novu API authentication failed - invalid secret key"
            exit 1
          else
            echo "‚ö†Ô∏è  Novu API returned HTTP $HTTP_CODE"
            cat /tmp/novu_response.json 2>/dev/null || echo "No response body"
            exit 1
          fi
          
        else
          echo "‚ö†Ô∏è  Novu secret key not configured - using test environment"
        fi
        
        if [ -n "$NEXT_PUBLIC_NOVU_APPLICATION_IDENTIFIER" ] && [ "$NEXT_PUBLIC_NOVU_APPLICATION_IDENTIFIER" != "your_app_identifier" ]; then
          echo "‚úÖ Novu application identifier is configured"
        else
          echo "‚ö†Ô∏è  Novu application identifier not configured - using test environment"
        fi
      env:
        NOVU_SECRET_KEY: ${{ secrets.NOVU_SECRET_KEY }}
        NEXT_PUBLIC_NOVU_APPLICATION_IDENTIFIER: ${{ secrets.NEXT_PUBLIC_NOVU_APPLICATION_IDENTIFIER }}

    - name: Verify Supabase connection
      run: |
        echo "üóÑÔ∏è  Testing Supabase connection..."
        if [ -n "$NEXT_PUBLIC_SUPABASE_URL" ] && [ -n "$NEXT_PUBLIC_SUPABASE_ANON_KEY" ]; then
          echo "‚úÖ Supabase environment variables are configured"
          echo "üìç URL: $NEXT_PUBLIC_SUPABASE_URL"
          echo "üîë Anon Key: ${NEXT_PUBLIC_SUPABASE_ANON_KEY:0:20}..."
          
          # Test Supabase REST API connection (matching status.ts logic)
          echo "üß™ Testing Supabase REST API with credentials..."
          SUPABASE_RESPONSE=$(curl -s -w "%{http_code}" -o /tmp/supabase_response.json \
            --connect-timeout 10 \
            -H "apikey: $NEXT_PUBLIC_SUPABASE_ANON_KEY" \
            -H "Authorization: Bearer $NEXT_PUBLIC_SUPABASE_ANON_KEY" \
            -H "Content-Type: application/json" \
            "$NEXT_PUBLIC_SUPABASE_URL/rest/v1/")
          
          HTTP_CODE=$(echo "$SUPABASE_RESPONSE" | tail -c 4)
          
          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ Supabase REST API connection successful"
          elif [ "$HTTP_CODE" = "401" ]; then
            echo "‚ùå Supabase authentication failed - invalid anon key"
            exit 1
          elif [ "$HTTP_CODE" = "403" ]; then
            echo "‚ùå Supabase access forbidden - check RLS policies"
            exit 1
          else
            echo "‚ö†Ô∏è  Supabase API returned HTTP $HTTP_CODE"
            cat /tmp/supabase_response.json 2>/dev/null || echo "No response body"
            exit 1
          fi
          
          # Test PostgreSQL connection if DATABASE_URL is provided
          if [ -n "$DATABASE_URL" ]; then
            echo "üêò Testing PostgreSQL connection..."
            echo "üìç Database URL: $(echo "$DATABASE_URL" | sed 's/:\/\/[^:]*:[^@]*@/:\/\/***:***@/')"
            
            # Install psql if not available
            if ! command -v psql >/dev/null 2>&1; then
              echo "üì¶ Installing PostgreSQL client..."
              sudo apt-get update -qq
              sudo apt-get install -y postgresql-client
            fi
            
            # Test PostgreSQL connection with timeout
            if timeout 10s psql "$DATABASE_URL" -c "SELECT version();" > /tmp/pg_response.txt 2>&1; then
              echo "‚úÖ PostgreSQL connection successful"
              PG_VERSION=$(head -1 /tmp/pg_response.txt | cut -d',' -f1)
              echo "üìä $PG_VERSION"
            else
              echo "‚ùå PostgreSQL connection failed"
              cat /tmp/pg_response.txt 2>/dev/null
              exit 1
            fi
          else
            echo "‚ÑπÔ∏è  DATABASE_URL not provided - skipping PostgreSQL test"
          fi
        else
          echo "‚ö†Ô∏è  Supabase environment variables not configured - tests will use mocked Supabase"
        fi
      env:
        NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
        NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
        DATABASE_URL: ${{ secrets.DATABASE_URL }}

    - name: Run tests
      run: pnpm test
      env:
        CI: true
        REDIS_URL: redis://localhost:6379
        RULE_ENGINE_ENABLED: true
        RULE_ENGINE_TIMEZONE: UTC
        RULE_ENGINE_MAX_CONCURRENT_JOBS: 5
        RULE_ENGINE_RETRY_ATTEMPTS: 2
        RULE_ENGINE_RETRY_DELAY: 1000
        NODE_ENV: test
        # Connection test credentials
        NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
        NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
        DATABASE_URL: ${{ secrets.DATABASE_URL }}
        NOVU_SECRET_KEY: ${{ secrets.NOVU_SECRET_KEY }}
        NEXT_PUBLIC_NOVU_APPLICATION_IDENTIFIER: ${{ secrets.NEXT_PUBLIC_NOVU_APPLICATION_IDENTIFIER }}